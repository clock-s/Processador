# üìò Documenta√ß√£o Completa do Processador de 8 Bits

## üéØ Vis√£o Geral

Este documento descreve um processador completo de 8 bits implementado em VHDL, incluindo sua arquitetura, conjunto de instru√ß√µes, componentes e funcionamento interno.

### Caracter√≠sticas Principais
- **Arquitetura**: 8 bits
- **Mem√≥ria ROM**: 256 posi√ß√µes (endere√ßamento de 8 bits)
- **Registradores**: 8 registradores (4 de mem√≥ria + 4 matem√°ticos)
- **ULA Completa**: 12 opera√ß√µes diferentes
- **Conjunto de Instru√ß√µes**: 15+ instru√ß√µes
- **Pipeline**: M√°quina de estados com 7 estados

---

## üèóÔ∏è Arquitetura do Processador

### Diagrama de Blocos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    UNIDADE DE CONTROLE                      ‚îÇ
‚îÇ                         (C_UNIT)                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   PC     ‚îÇ  ‚îÇ  FLAGS   ‚îÇ  ‚îÇ   ACC    ‚îÇ  ‚îÇ    MA    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ         ‚îÇ              ‚îÇ              ‚îÇ              ‚îÇ      ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îÇ                          ‚îÇ                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ              ‚îÇ              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   Mem√≥ria    ‚îÇ  ‚îÇ  ULA   ‚îÇ  ‚îÇRegistradores‚îÇ
    ‚îÇ     ROM      ‚îÇ  ‚îÇ 8 bits ‚îÇ  ‚îÇ   (x8)      ‚îÇ
    ‚îÇ  (256x8)     ‚îÇ  ‚îÇ        ‚îÇ  ‚îÇ             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Componentes Principais

#### 1. **Unidade de Controle (C_UNIT)**
- Gerencia o ciclo de busca-decodifica√ß√£o-execu√ß√£o
- Controla o fluxo de dados entre todos os componentes
- Mant√©m o Program Counter (PC)
- Gerencia registradores especiais
- **Implementa internamente os 8 registradores**:
  - **4 registradores de mem√≥ria** (r1, r2, r3, r4) - array `mem_regs`
  - **4 registradores matem√°ticos** (x, y, z, w) - array `math_regs`

#### 2. **Unidade L√≥gica Aritm√©tica (ULA)**
- Realiza todas as opera√ß√µes matem√°ticas e l√≥gicas
- Suporta opera√ß√µes com flag de conclus√£o
- Overflow detection

#### 3. **Mem√≥ria ROM (Archive)**
- 256 posi√ß√µes de 8 bits
- Carrega programas de arquivo externo (.bin)
- Leitura s√≠ncrona

#### 4. **Banco de Registradores (INTERNO)**
- **N√£o usa componente externo PACK_REGISTERS**
- 4 registradores de mem√≥ria (r1-r4) implementados como array interno
- 4 registradores matem√°ticos (x-w) implementados como array interno separado
- Acesso direto via sinais internos

---

## üíæ Organiza√ß√£o da Mem√≥ria e Registradores

### Registradores de Mem√≥ria (Memory Registers)
| Nome | C√≥digo | Descri√ß√£o |
|------|--------|-----------|
| r1   | 00     | Registrador de uso geral 1 (armazenado internamente na C_UNIT) |
| r2   | 01     | Registrador de uso geral 2 (armazenado internamente na C_UNIT) |
| r3   | 10     | Registrador de uso geral 3 (armazenado internamente na C_UNIT) |
| r4   | 11     | Registrador de uso geral 4 (armazenado internamente na C_UNIT) |

**Nota Importante**: Os registradores r1-r4 s√£o **implementados internamente** na Unidade de Controle como um array de 4 posi√ß√µes, completamente separado dos registradores matem√°ticos.

### Registradores Matem√°ticos (Math Registers)
| Nome | C√≥digo | Descri√ß√£o |
|------|--------|-----------|
| x    | 00     | Registrador matem√°tico X (usado pela ULA) |
| y    | 01     | Registrador matem√°tico Y (usado pela ULA) |
| z    | 10     | Registrador matem√°tico Z (usado pela ULA) |
| w    | 11     | Registrador matem√°tico W (usado pela ULA) |

**Nota Importante**: Os registradores x, y, z, w s√£o **implementados internamente** na Unidade de Controle como um array separado de 4 posi√ß√µes. Estes s√£o os registradores principais para opera√ß√µes da ULA.

### Registradores Especiais

#### **Accumulator (ACC)**
- Armazena o √∫ltimo resultado de opera√ß√£o da ULA
- 8 bits

#### **Program Counter (PC)**
- Contador de programa (0-255)
- Incrementado automaticamente
- Modificado por instru√ß√µes JUMP

#### **Memory Address (MA)**
- Registrador de endere√ßo de mem√≥ria
- Usado para endere√ßamento indireto
- 8 bits (0-255)

#### **Flags Register (FLAGS)**
| Bit | Nome | Descri√ß√£o |
|-----|------|-----------|
| 0   | Z    | Zero - Resultado √© zero |
| 1   | N    | Negative - Resultado √© negativo (bit 7 = 1) |
| 2   | C    | Carry - Overflow/Carry da opera√ß√£o |
| 3   | P    | Parity - Paridade do resultado |
| 7   | K    | oVerflow - C√≥pia do carry para jumps condicionais |

---

## üìã Conjunto de Instru√ß√µes

### Formato das Instru√ß√µes

As instru√ß√µes t√™m tamanho vari√°vel:
- **1 byte**: Instru√ß√£o b√°sica (NOP, RES, RESF)
- **2 bytes**: Instru√ß√£o + registrador/operando
- **3 bytes**: Instru√ß√£o + dois operandos
- **3 bytes**: Instru√ß√µes JUMP

### Codifica√ß√£o de Instru√ß√µes

#### **Nibble Superior (bits 7-4)**: Determina o tipo de opera√ß√£o

| C√≥digo | Instru√ß√£o | Descri√ß√£o |
|--------|-----------|-----------|
| 0x0X   | NOP/RES/RESF/COMP | Controle e compara√ß√£o |
| 0x1X   | LOAD Math ‚Üê Mem | Carrega registrador matem√°tico da mem√≥ria |
| 0x2X   | LOAD Mem ‚Üê Math | Carrega registrador de mem√≥ria do matem√°tico |
| 0x3X   | LOAD Mem ‚Üê Mem/Val | Carrega registrador de mem√≥ria |
| 0x4X   | LOAD Special | Opera√ß√µes com registradores especiais |
| 0x5X   | JUMP/RSHIFT | Saltos e deslocamento √† direita |
| 0x6X   | SUM | Adi√ß√£o |
| 0x7X   | MULT | Multiplica√ß√£o |
| 0x8X   | AND/NOT | Opera√ß√µes l√≥gicas |
| 0x9X   | OR/RSHIFT | OU l√≥gico e shift |
| 0xAX   | XOR/RSHIFT | XOR e shift |
| 0xBX   | SUB | Subtra√ß√£o |
| 0xCX   | DIV/LSHIFT | Divis√£o e shift esquerda |
| 0xDX   | MOD/LSHIFT | M√≥dulo e shift |
| 0xEX   | DIV/MOD/RSHIFT | Opera√ß√µes estendidas |
| 0xFX   | LSHIFT | Deslocamento √† esquerda |

---

## üîß Instru√ß√µes Detalhadas

### 1. Instru√ß√µes Aritm√©ticas

#### **SUM - Adi√ß√£o (0x6X)**

**Formato**: `SUM operando1, operando2`

**Varia√ß√µes**:
- `SUM x, y` - Soma dois registradores matem√°ticos
- `SUM x, 10` - Soma registrador com valor imediato
- `SUM 5, 10` - Soma dois valores imediatos

**Codifica√ß√£o**:
```
0x60 + c√≥digo_operando1 + c√≥digo_operando2
```

**Exemplos**:
```assembly
SUM x, y;      # 0x60  -> x = x + y
SUM x, 5;      # 0x6D 0x05  -> x = x + 5
SUM 10, 20;    # 0x6E 0x0A 0x14  -> resultado em ACC
```

**Flags Afetadas**: Z, N, C, K

---

#### **SUB - Subtra√ß√£o (0xBX)**

**Formato**: `SUB operando1, operando2`

**Descri√ß√£o**: Subtrai operando2 de operando1

**Codifica√ß√£o**:
```
0xB0 + c√≥digo_operando1 + c√≥digo_operando2
```

**Exemplos**:
```assembly
SUB x, y;      # 0xB0  -> x = x - y
SUB y, 5;      # 0xB4 0x05  -> y = y - 5
SUB 100, 30;   # 0xBE 0x64 0x1E  -> resultado em ACC
```

**Flags Afetadas**: Z, N, C, K

---

#### **MULT - Multiplica√ß√£o (0x7X)**

**Formato**: `MULT operando1, operando2`

**Descri√ß√£o**: Multiplica dois operandos (resultado de 8 bits)

**Codifica√ß√£o**:
```
0x70 + c√≥digo_operando1 + c√≥digo_operando2
```

**Exemplos**:
```assembly
MULT x, y;     # 0x70  -> x = x * y
MULT z, 3;     # 0x78 0x03  -> z = z * 3
MULT 12, 5;    # 0x7E 0x0C 0x05  -> resultado em ACC
```

**Caracter√≠sticas**:
- Opera√ß√£o sequencial (m√∫ltiplos ciclos)
- Flag de conclus√£o indica fim da opera√ß√£o
- Overflow guardado no bit C

**Flags Afetadas**: Z, N, C, K

---

#### **DIV - Divis√£o (0xCX/0xDX)**

**Formato**: `DIV operando1, operando2`

**Descri√ß√£o**: Divide operando1 por operando2 (resultado inteiro)

**Exemplos**:
```assembly
DIV x, y;      # x = x / y
DIV z, 4;      # z = z / 4
```

**Caracter√≠sticas**:
- Opera√ß√£o sequencial (m√∫ltiplos ciclos)
- Divis√£o por zero n√£o tratada (resultado indefinido)
- Apenas parte inteira do resultado

**Flags Afetadas**: Z, N

---

#### **MOD - M√≥dulo (0xDX)**

**Formato**: `MOD operando1, operando2`

**Descri√ß√£o**: Resto da divis√£o de operando1 por operando2

**Exemplos**:
```assembly
MOD x, y;      # x = x % y
MOD w, 10;     # w = w % 10
```

**Flags Afetadas**: Z, N

---

### 2. Instru√ß√µes L√≥gicas

#### **AND - E L√≥gico (0x8X)**

**Formato**: `AND operando1, operando2`

**Descri√ß√£o**: Realiza AND bit a bit

**Exemplos**:
```assembly
AND x, y;      # 0x80  -> x = x & y
AND z, 0x0F;   # 0x88 0x0F  -> z = z & 0x0F (m√°scara)
```

**Uso Comum**: M√°scaras de bits, isolamento de bits espec√≠ficos

**Flags Afetadas**: Z, N

---

#### **OR - OU L√≥gico (0x9X)**

**Formato**: `OR operando1, operando2`

**Descri√ß√£o**: Realiza OR bit a bit

**Exemplos**:
```assembly
OR x, y;       # 0x90  -> x = x | y
OR w, 0x80;    # 0x9C 0x80  -> w = w | 0x80 (set bit 7)
```

**Uso Comum**: Ativa√ß√£o de bits, combina√ß√£o de flags

**Flags Afetadas**: Z, N

---

#### **XOR - OU Exclusivo (0xAX)**

**Formato**: `XOR operando1, operando2`

**Descri√ß√£o**: Realiza XOR bit a bit

**Exemplos**:
```assembly
XOR x, y;      # 0xA0  -> x = x ^ y
XOR z, 0xFF;   # 0xA8 0xFF  -> z = ~z (invers√£o)
```

**Uso Comum**: Toggle de bits, invers√£o, criptografia simples

**Flags Afetadas**: Z, N

---

#### **NOT - Nega√ß√£o L√≥gica (0x8X)**

**Formato**: `NOT operando`

**Descri√ß√£o**: Inverte todos os bits do operando

**Exemplos**:
```assembly
NOT x;         # 0x8D  -> x = ~x
NOT 0xAA;      # 0x89 0xAA  -> resultado = 0x55
```

**Flags Afetadas**: Z, N

---

### 3. Instru√ß√µes de Deslocamento (Shift)

#### **LSHIFT - Deslocamento √† Esquerda (0xCX/0xFX)**

**Formato**: `LSHIFT operando, quantidade`

**Descri√ß√£o**: Desloca bits para a esquerda

**Exemplos**:
```assembly
LSHIFT x, y;   # 0xF0  -> x = x << y
LSHIFT z, 3;   # 0xC9 0x03  -> z = z << 3
```

**Caracter√≠sticas**:
- Bits √† direita preenchidos com 0
- Bits perdidos √† esquerda v√£o para carry
- Equivalente a multiplica√ß√£o por 2^n

**Flags Afetadas**: Z, N, C

---

#### **RSHIFT - Deslocamento √† Direita (0x5X/0x9X/0xAX)**

**Formato**: `RSHIFT operando, quantidade`

**Descri√ß√£o**: Desloca bits para a direita

**Exemplos**:
```assembly
RSHIFT x, y;   # 0x94  -> x = x >> y
RSHIFT w, 2;   # 0x5F 0x02  -> w = w >> 2
```

**Caracter√≠sticas**:
- Bits √† esquerda preenchidos com 0
- Bits perdidos √† direita v√£o para carry
- Equivalente a divis√£o por 2^n

**Flags Afetadas**: Z, N, C

---

### 4. Instru√ß√µes de Compara√ß√£o

#### **COMP - Compara√ß√£o (0x0C)**

**Formato**: `COMP operando1, operando2`

**Descri√ß√£o**: Compara dois operandos e atualiza flags

**Exemplos**:
```assembly
COMP x, y;     # Compara x com y
COMP z, 10;    # Compara z com 10
```

**Flags Geradas**:
- **Z**: Igual (operando1 == operando2)
- **N**: Menor (operando1 < operando2)
- **C**: Maior (operando1 > operando2)
- **P**: Paridade

**Uso**: Prepara√ß√£o para jumps condicionais

---

### 5. Instru√ß√µes de Controle de Fluxo

#### **JUMP - Salto Incondicional (0x54)**

**Formato**: `JUMP -label;`

**Descri√ß√£o**: Salta para um endere√ßo espec√≠fico

**Codifica√ß√£o**:
```
0x54 [endere√ßo]
```

**Exemplo**:
```assembly
-inicio;       # Define label "inicio"
LOAD x, 10;
JUMP -inicio;  # 0x54 [addr]  -> PC = addr
```

---

#### **JUMP Condicional (0x55)**

**Formato**: `JUMP -label, flags;`

**Descri√ß√£o**: Salta se as condi√ß√µes de flag forem atendidas

**Codifica√ß√£o**:
```
0x55 [endere√ßo] [m√°scara_flags]
```

**Flags de Condi√ß√£o**:
- **z**: Salta se Zero (resultado = 0)
- **n**: Salta se Negative (resultado < 0)
- **c**: Salta se Carry (overflow)
- **p**: Salta se Parity (paridade par)
- **k**: Salta se oVerflow

**Exemplos**:
```assembly
COMP x, y;
JUMP -maior, c;    # Salta se x > y
JUMP -igual, z;    # Salta se x == y
JUMP -menor, n;    # Salta se x < y
JUMP -overflow, k; # Salta se houve overflow
```

**Combina√ß√£o de Flags**:
```assembly
JUMP -label, zc;   # Salta se Z=1 OU C=1
JUMP -label, nk;   # Salta se N=1 OU K=1
```

---

#### **NOP - No Operation (0x00)**

**Formato**: `NOP;`

**Descri√ß√£o**: Nenhuma opera√ß√£o (delay de 1 ciclo)

**Exemplo**:
```assembly
NOP;           # 0x00  -> Apenas incrementa PC
```

**Uso**: Timing, alinhamento, debugging

---

### 6. Instru√ß√µes de Movimenta√ß√£o de Dados

#### **LOAD - Carregar Dados (0x1X - 0x4X)**

**Formato**: `LOAD destino, origem`

**Varia√ß√µes**:

##### **a) Math_reg ‚Üê Memory_reg (0x1X)**
```assembly
LOAD x, r1;    # 0x10  -> x = r1
LOAD y, r2;    # 0x15  -> y = r2
LOAD z, r3;    # 0x1A  -> z = r3
LOAD w, r4;    # 0x1F  -> w = r4
```

##### **b) Memory_reg ‚Üê Math_reg (0x2X)**
```assembly
LOAD r1, x;    # 0x20  -> r1 = x
LOAD r2, y;    # 0x25  -> r2 = y
LOAD r3, z;    # 0x2A  -> r3 = z
LOAD r4, w;    # 0x2F  -> r4 = w
```

##### **c) Memory_reg ‚Üê Memory_reg (0x3X)**
```assembly
LOAD r1, r2;   # 0x31  -> r1 = r2
LOAD r3, r4;   # 0x3F  -> r3 = r4
```

##### **d) Memory_reg ‚Üê Valor Imediato (0x3X)**
```assembly
LOAD r1, 255;  # 0x30 0xFF  -> r1 = 255
LOAD r2, 42;   # 0x35 0x2A  -> r2 = 42
```

##### **e) Registradores Especiais (0x4X)**
```assembly
LOAD r1, a;    # r1 = accumulator
LOAD r1, ma;   # r1 = memory address register
LOAD ma, r1;   # memory address = r1
LOAD r1, [ma]; # r1 = memory[ma] (endere√ßamento indireto)
```

---

### 7. Instru√ß√µes de Sistema

#### **RES - Reset Registers (0x01)**

**Formato**: `RES;`

**Descri√ß√£o**: Zera todos os registradores matem√°ticos (x, y, z, w)

**Exemplo**:
```assembly
RES;           # 0x01  -> x=0, y=0, z=0, w=0
```

---

#### **RESF - Reset Flags (0x02)**

**Formato**: `RESF;`

**Descri√ß√£o**: Zera todas as flags (Z, N, C, P, K)

**Exemplo**:
```assembly
RESF;          # 0x02  -> FLAGS = 0x00
```

---

## ‚öôÔ∏è Unidade L√≥gica Aritm√©tica (ULA)

### Opera√ß√µes da ULA

| C√≥digo | Opera√ß√£o | Descri√ß√£o |
|--------|----------|-----------|
| 0000   | SUM      | Adi√ß√£o com carry |
| 0001   | SUB      | Subtra√ß√£o |
| 0010   | COMP     | Compara√ß√£o |
| 0011   | XOR      | XOR bit a bit |
| 0100   | NOT      | Invers√£o de bits |
| 0101   | AND      | E l√≥gico |
| 0110   | OR       | OU l√≥gico |
| 0111   | MULT     | Multiplica√ß√£o |
| 1000   | DIV      | Divis√£o inteira |
| 1001   | MOD      | M√≥dulo (resto) |
| 1010   | LSHIFT   | Deslocamento esquerda |
| 1011   | RSHIFT   | Deslocamento direita |

### Caracter√≠sticas da ULA

#### **Opera√ß√µes S√≠ncronas**
Todas as opera√ß√µes s√£o s√≠ncronas com o clock.

#### **Sistema de Permiss√£o**
- Sinal `permission` deve estar em '1' para iniciar opera√ß√£o
- ULA permanece idle enquanto `permission = '0'`

#### **Flag de Conclus√£o**
- Opera√ß√µes complexas (MULT, DIV, MOD, SHIFT) usam m√∫ltiplos ciclos
- Sinal `finished` indica quando a opera√ß√£o est√° completa
- Unidade de controle aguarda `finished = '1'` antes de prosseguir

#### **Detec√ß√£o de Overflow**
- Sinal `overflow` indica carry/overflow
- Atualiza flags C e K automaticamente

---

## üîÑ M√°quina de Estados da Unidade de Controle

### Estados do Processador

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FETCH  ‚îÇ  Busca instru√ß√£o da mem√≥ria
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ DECODE  ‚îÇ  Decodifica instru√ß√£o e identifica operandos
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GET_VALUE1   ‚îÇ  Busca primeiro operando (se necess√°rio)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GET_VALUE2   ‚îÇ  Busca segundo operando (se necess√°rio)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ EXECUTE  ‚îÇ  Executa opera√ß√£o na ULA ou controle
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ WRITE_BACK ‚îÇ  Escreve resultado e atualiza flags
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  HALT   ‚îÇ  Estado de parada (opcional)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Descri√ß√£o dos Estados

#### **1. FETCH**
- **Fun√ß√£o**: Buscar pr√≥xima instru√ß√£o da ROM
- **A√ß√µes**:
  - Envia PC para endere√ßo da ROM
  - Desabilita permiss√£o da ULA
  - Configura registradores para modo leitura
- **Pr√≥ximo Estado**: DECODE

#### **2. DECODE**
- **Fun√ß√£o**: Interpretar o opcode da instru√ß√£o
- **A√ß√µes**:
  - Analisa nibble superior (bits 7-4) para tipo de instru√ß√£o
  - Extrai c√≥digos de registradores dos bits inferiores
  - Determina se precisa de valores imediatos
  - Identifica opera√ß√£o da ULA necess√°ria
  - Incrementa PC
- **Pr√≥ximo Estado**: 
  - GET_VALUE1 (se precisa de operandos)
  - EXECUTE (se n√£o precisa de operandos)
  - FETCH (para NOP, RES, RESF)

#### **3. GET_VALUE1**
- **Fun√ß√£o**: Obter primeiro operando
- **A√ß√µes**:
  - Se valor imediato: busca da ROM usando PC, incrementa PC
  - Se registrador: l√™ do banco de registradores ou registradores matem√°ticos
  - Armazena em `operand1`
- **Pr√≥ximo Estado**:
  - GET_VALUE2 (se precisa de segundo operando)
  - EXECUTE (se tem todos os operandos)

#### **4. GET_VALUE2**
- **Fun√ß√£o**: Obter segundo operando
- **A√ß√µes**:
  - Busca da ROM usando PC
  - Incrementa PC
  - Armazena em `operand2`
- **Pr√≥ximo Estado**: EXECUTE

#### **5. EXECUTE**
- **Fun√ß√£o**: Executar a opera√ß√£o
- **A√ß√µes para opera√ß√µes da ULA**:
  - Carrega `ULA_A` com operand1
  - Carrega `ULA_B` com operand2
  - Define `ULA_instruction` com c√≥digo da opera√ß√£o
  - Ativa `ULA_permission`
  - Para MULT, DIV, MOD, SHIFT: aguarda `ULA_finished`
- **A√ß√µes para JUMP**:
  - Verifica condi√ß√µes de flag (se condicional)
  - Atualiza PC com endere√ßo de destino
- **Pr√≥ximo Estado**: WRITE_BACK

#### **6. WRITE_BACK**
- **Fun√ß√£o**: Armazenar resultado da opera√ß√£o
- **A√ß√µes**:
  - Aguarda `ULA_finished = '1'` (se necess√°rio)
  - Captura `ULA_OUTPUT`
  - Escreve em registrador de destino apropriado
  - Atualiza accumulator (ACC)
  - Atualiza flags:
    - Z: resultado = 0
    - N: resultado < 0 (bit 7 = 1)
    - C: carry/overflow da ULA
    - K: overflow da ULA
  - Desativa `ULA_permission`
- **Pr√≥ximo Estado**: FETCH

#### **7. HALT**
- **Fun√ß√£o**: Parar execu√ß√£o
- **A√ß√µes**: Nenhuma (estado de espera)
- **Pr√≥ximo Estado**: HALT (permanece)

---

## üìù Exemplos de Programas

### Exemplo 1: Soma Simples
```assembly
# Programa: Soma de dois n√∫meros
# Resultado em x

LOAD x, 10;      # x = 10
LOAD y, 20;      # y = 20
SUM x, y;        # x = x + y = 30
LOAD r1, x;      # r1 = x (armazena resultado)
```

**C√≥digo de M√°quina**:
```
0x6D 0x0A     # LOAD x, 10
0x64 0x14     # LOAD y, 20
0x60          # SUM x, y
0x20          # LOAD r1, x
```

---

### Exemplo 2: Loop Contador
```assembly
# Programa: Conta de 0 a 10

RES;             # Zera registradores
LOAD x, 0;       # x = 0 (contador)
LOAD y, 10;      # y = 10 (limite)

-loop;
LOAD r1, x;      # Armazena contador atual
SUM x, 1;        # x = x + 1
COMP x, y;       # Compara x com y
JUMP -loop, n;   # Se x < y, volta para loop
```

**C√≥digo de M√°quina**:
```
0x01          # RES
0x6D 0x00     # LOAD x, 0
0x64 0x0A     # LOAD y, 10
0x20          # LOAD r1, x (endere√ßo 4)
0x6D 0x01     # SUM x, 1
0x0C          # COMP x, y
0x55 0x04 0x02 # JUMP -loop, n
```

---

### Exemplo 3: Fatorial
```assembly
# Programa: Calcula fatorial de 5
# Resultado em x

LOAD x, 5;       # N√∫mero para calcular fatorial
LOAD y, 1;       # y = resultado (inicia com 1)
LOAD z, 1;       # z = contador

-loop;
MULT y, x;       # y = y * x
SUB x, z;        # x = x - 1
COMP x, z;       # Compara x com 1
JUMP -loop, c;   # Se x > 1, continua loop

LOAD r1, y;      # Armazena resultado final
```

---

### Exemplo 4: Opera√ß√µes Bit a Bit
```assembly
# Programa: Manipula√ß√£o de bits

LOAD x, 0b10101010;  # x = 0xAA
LOAD y, 0b11110000;  # y = 0xF0

AND x, y;            # x = 0xA0 (bits comuns)
LOAD r1, x;          # Salva resultado AND

LOAD x, 0b10101010;
OR x, y;             # x = 0xFA (todos os bits)
LOAD r2, x;          # Salva resultado OR

LOAD x, 0b10101010;
XOR x, y;            # x = 0x5A (bits diferentes)
LOAD r3, x;          # Salva resultado XOR

NOT x;               # x = 0xA5 (inverte bits)
LOAD r4, x;          # Salva resultado NOT
```

---

### Exemplo 5: Divis√£o e M√≥dulo
```assembly
# Programa: Divide 100 por 7
# Quociente e resto

LOAD x, 100;         # Dividendo
LOAD y, 7;           # Divisor

DIV x, y;            # x = 100 / 7 = 14
LOAD r1, x;          # r1 = quociente

LOAD x, 100;
MOD x, y;            # x = 100 % 7 = 2
LOAD r2, x;          # r2 = resto
```

---

### Exemplo 6: Deslocamento de Bits
```assembly
# Programa: Multiplica√ß√£o e divis√£o por pot√™ncias de 2

LOAD x, 5;           # x = 5 (0b00000101)

LSHIFT x, 1;         # x = 10 (multiplica por 2)
LOAD r1, x;

LSHIFT x, 2;         # x = 40 (multiplica por 4)
LOAD r2, x;

RSHIFT x, 3;         # x = 5 (divide por 8)
LOAD r3, x;
```

---

### Exemplo 7: Verifica√ß√£o de Paridade
```assembly
# Programa: Verifica se n√∫mero tem paridade par

LOAD x, 0b10110101;  # N√∫mero a verificar
COMP x, x;           # COMP atualiza flag de paridade
JUMP -par, p;        # Salta se paridade par
JUMP -impar;

-par;
LOAD r1, 1;          # r1 = 1 (paridade par)
JUMP -fim;

-impar;
LOAD r1, 0;          # r1 = 0 (paridade √≠mpar)

-fim;
```

---

### Exemplo 8: Busca de M√°ximo
```assembly
# Programa: Encontra o maior entre 3 n√∫meros

LOAD r1, 25;         # Primeiro n√∫mero
LOAD r2, 42;         # Segundo n√∫mero
LOAD r3, 17;         # Terceiro n√∫mero

LOAD x, r1;          # x = primeiro
LOAD y, r2;
COMP x, y;
JUMP -x_maior1, c;   # Se x > y
LOAD x, r2;          # x = y (y √© maior)

-x_maior1;
LOAD y, r3;
COMP x, y;
JUMP -fim, c;        # Se x > z, x √© o maior
LOAD x, r3;          # x = z (z √© o maior)

-fim;
LOAD r4, x;          # r4 = m√°ximo
```

---

## üî¨ Componentes VHDL Detalhados

### 1. **C_UNIT.vhd** - Unidade de Controle

**Interface**:
```vhdl
entity C_UNIT is port(
    clock       : in  std_logic;
    reset       : in  std_logic;
    debug_pc    : out integer range 0 to 255;
    debug_state : out std_logic_vector(2 downto 0)
);
```

**Sinais Internos Principais**:
- `PC`: Program Counter (0-255)
- `current_state`: Estado atual da m√°quina
- `opcode`: Instru√ß√£o sendo executada
- `operand1, operand2`: Operandos da instru√ß√£o
- **`mem_regs`**: Array de 4 registradores de mem√≥ria (r1, r2, r3, r4)
- **`math_regs`**: Array de 4 registradores matem√°ticos (x, y, z, w)
- `flags_reg`: Registrador de flags
- `acc_reg`: Accumulator

**Importante**: Esta unidade de controle **n√£o usa o componente PACK_REGISTERS_PORTS**. Os registradores r1-r4 e x-w s√£o implementados como arrays internos separados dentro da C_UNIT.

---

### 2. **ULA.vhd** - Unidade L√≥gica Aritm√©tica

**Interface**:
```vhdl
entity ULA is port(
    output      : out std_logic_vector (7 downto 0);
    finished    : out std_logic;
    overflow    : out std_logic;
    
    A           : in std_logic_vector (7 downto 0);
    B           : in std_logic_vector (7 downto 0);
    permission  : in std_logic;
    instruction : in std_logic_vector (3 downto 0);
    clock       : in std_logic   
);
```

**Componentes Internos**:
- `SUM_8_BITS`: Somador completo de 8 bits
- `SUBTRACTION_8_BITS`: Subtrator de 8 bits
- `MULT`: Multiplicador sequencial
- `MOD_DIV`: Divisor e m√≥dulo sequencial
- `COMPARE`: Comparador
- `BIT_WISE`: Opera√ß√µes l√≥gicas bit a bit
- `L_SHIFT`: Deslocamento √† esquerda
- `R_SHIFT`: Deslocamento √† direita

---

### 3. **archive.vhd** - Mem√≥ria ROM

**Interface**:
```vhdl
entity archive is port(
    data : out std_logic_vector (7 downto 0);
    addr : in  integer range 0 to 255
);
```

**Caracter√≠sticas**:
- L√™ arquivo "teste.bin" na inicializa√ß√£o
- Formato hexadecimal (2 d√≠gitos por linha)
- 256 posi√ß√µes de 8 bits
- Acesso s√≠ncrono

**Formato do Arquivo .bin**:
```
6D
0A
64
14
60
20
00
```

---

### 4. **pack_register.vhd** - Banco de Registradores

**Interface**:
```vhdl
entity PACK_REGISTERS_PORTS is port(
    clock      : in    std_logic;
    reset      : in    std_logic;
    write_read : in    std_logic;  -- 0=read, 1=write
    addr       : in    std_logic_vector (1 downto 0);
    data       : inout std_logic_vector (7 downto 0)
);
```

**Caracter√≠sticas**:
- 4 registradores (endere√ßados por 2 bits)
- Barramento bidirecional
- Reset ass√≠ncrono
- Escritura/leitura controlada por sinal

---

### 5. Componentes Auxiliares

#### **sum.vhd** - Somador
- Somador completo de 1 bit
- Somador de 8 bits com carry in/out

#### **sub.vhd** - Subtrator
- Usa complemento de 2
- Gera flag de carry/borrow

#### **mult.vhd** - Multiplicador
- Multiplica√ß√£o sequencial
- 8 ciclos de clock
- Usa soma e shift
- Suporta n√∫meros negativos (complemento de 2)

#### **DIV_MOD.vhd** - Divisor/M√≥dulo
- Divis√£o sequencial (algoritmo de Restoring Division)
- Gera quociente e resto
- Flag de conclus√£o

#### **bit_wise.vhd** - Opera√ß√µes L√≥gicas
- Selector de 2 bits para escolher opera√ß√£o:
  - 00: AND
  - 01: OR
  - 10: XOR
  - 11: NOT

#### **l_shift.vhd** / **r_shift.vhd** - Deslocadores
- Deslocamento sequencial
- Suporta quantidade vari√°vel de shifts
- Flag de carry para bits perdidos

#### **comp.vhd** - Comparador
- Gera 4 flags de compara√ß√£o
- Suporta igual, maior, menor
- Calcula paridade

---

## üõ†Ô∏è Compilador

### **compiler.cpp** - Compilador Assembly para Bin√°rio

**Fun√ß√£o**: Converte c√≥digo assembly em bin√°rio execut√°vel

**Processo de Compila√ß√£o**:

1. **Primeira Passagem**:
   - Identifica labels (jumppoints) e seus endere√ßos
   - Conta instru√ß√µes para calcular PCs corretos

2. **Segunda Passagem**:
   - Gera c√≥digo de m√°quina
   - Resolve endere√ßos de jumps
   - Escreve arquivo .bin

**Sintaxe do Assembly**:
```assembly
# Coment√°rios come√ßam com #

# Labels come√ßam com - e terminam com ;
-meu_label;

# Instru√ß√µes terminam com ;
LOAD x, 10;
SUM x, y;

# Jumps referenciam labels com -
JUMP -meu_label;
JUMP -outro_label, zn;  # Condicional
```

**Uso**:
```bash
./compiler programa.gbf programa.bin
```

**Exemplo de Arquivo .gbf**:
```assembly
# Programa de teste
RES;
LOAD x, 5;
LOAD y, 3;
SUM x, y;
LOAD r1, x;
```

**Sa√≠da .bin**:
```
01
6D
05
64
03
60
20
```

---

## üìä Tabela Completa de Opcodes

### Instru√ß√µes de 1 Byte

| Opcode | Mnem√¥nico | Descri√ß√£o |
|--------|-----------|-----------|
| 0x00   | NOP       | Nenhuma opera√ß√£o |
| 0x01   | RES       | Reset registradores matem√°ticos |
| 0x02   | RESF      | Reset flags |

### Instru√ß√µes LOAD (2 bytes)

| Opcode | Mnem√¥nico | Descri√ß√£o |
|--------|-----------|-----------|
| 0x10   | LOAD x,r1 | x ‚Üê r1 |
| 0x11   | LOAD x,r2 | x ‚Üê r2 |
| 0x12   | LOAD x,r3 | x ‚Üê r3 |
| 0x13   | LOAD x,r4 | x ‚Üê r4 |
| 0x14   | LOAD y,r1 | y ‚Üê r1 |
| 0x15   | LOAD y,r2 | y ‚Üê r2 |
| ...    | ...       | ... |
| 0x20   | LOAD r1,x | r1 ‚Üê x |
| 0x21   | LOAD r1,y | r1 ‚Üê y |
| ...    | ...       | ... |

### Instru√ß√µes LOAD com Imediato (2 bytes)

| Opcode | Byte 2 | Mnem√¥nico | Descri√ß√£o |
|--------|--------|-----------|-----------|
| 0x30   | val    | LOAD r1,val | r1 ‚Üê val |
| 0x35   | val    | LOAD r2,val | r2 ‚Üê val |
| 0x3A   | val    | LOAD r3,val | r3 ‚Üê val |
| 0x3F   | val    | LOAD r4,val | r4 ‚Üê val |

### Instru√ß√µes Aritm√©ticas Registrador-Registrador (1 byte)

| Opcode | Mnem√¥nico | Descri√ß√£o |
|--------|-----------|-----------|
| 0x60   | SUM x,y   | x = x + y |
| 0x61   | SUM x,z   | x = x + z |
| 0x62   | SUM x,w   | x = x + w |
| 0x64   | SUM y,x   | y = y + x |
| 0x65   | SUM y,z   | y = y + z |
| ...    | ...       | ... |
| 0x70   | MULT x,y  | x = x * y |
| ...    | ...       | ... |
| 0xB0   | SUB x,y   | x = x - y |
| ...    | ...       | ... |

### Instru√ß√µes Aritm√©ticas com Imediato (2 bytes)

| Opcode | Byte 2 | Mnem√¥nico | Descri√ß√£o |
|--------|--------|-----------|-----------|
| 0x6D   | val    | SUM x,val | x = x + val |
| 0x64   | val    | SUM y,val | y = y + val |
| 0x7D   | val    | MULT x,val| x = x * val |
| 0xB4   | val    | SUB y,val | y = y - val |

### Instru√ß√µes L√≥gicas (1-2 bytes)

| Opcode | Byte 2 | Mnem√¥nico | Descri√ß√£o |
|--------|--------|-----------|-----------|
| 0x80   | -      | AND x,y   | x = x & y |
| 0x88   | val    | AND x,val | x = x & val |
| 0x8D   | -      | NOT x     | x = ~x |
| 0x89   | val    | NOT val   | resultado = ~val |
| 0x90   | -      | OR x,y    | x = x \| y |
| 0xA0   | -      | XOR x,y   | x = x ^ y |

### Instru√ß√µes de Shift (2 bytes)

| Opcode | Byte 2 | Mnem√¥nico | Descri√ß√£o |
|--------|--------|-----------|-----------|
| 0xC4   | val    | LSHIFT x,val | x = x << val |
| 0xC8   | val    | LSHIFT y,val | y = y << val |
| 0xF0   | -      | LSHIFT x,y   | x = x << y |
| 0x9D   | val    | RSHIFT x,val | x = x >> val |
| 0x94   | -      | RSHIFT x,x   | x = x >> x |

### Instru√ß√µes de Compara√ß√£o (1 byte)

| Opcode | Mnem√¥nico | Descri√ß√£o |
|--------|-----------|-----------|
| 0x0C   | COMP x,y  | Compara x com y |

### Instru√ß√µes de Salto (3 bytes)

| Opcode | Byte 2 | Byte 3 | Mnem√¥nico | Descri√ß√£o |
|--------|--------|--------|-----------|-----------|
| 0x54   | addr   | -      | JUMP addr | PC = addr |
| 0x55   | addr   | flags  | JUMP addr,flags | PC = addr se flags |

**M√°scaras de Flags para JUMP Condicional**:
- 0x01: Z (Zero)
- 0x02: N (Negative)
- 0x04: C (Carry)
- 0x08: K (oVerflow)
- 0x80: P (Parity)

---

## üéì Conceitos Avan√ßados

### 1. Complemento de 2

O processador usa complemento de 2 para representar n√∫meros negativos:

**Representa√ß√£o**:
- N√∫meros positivos: 0x00 (0) a 0x7F (127)
- N√∫meros negativos: 0x80 (-128) a 0xFF (-1)

**Convers√£o**:
1. Inverte todos os bits
2. Soma 1

**Exemplo**: -5
```
5  = 0b00000101
~5 = 0b11111010
+1 = 0b11111011 = 0xFB = -5
```

---

### 2. Flags e Condi√ß√µes

#### **Flag Zero (Z)**
- Ativada quando resultado = 0
- Uso: Detectar igualdade, fim de loops

#### **Flag Negative (N)**
- Ativada quando bit 7 = 1
- Uso: Detectar n√∫meros negativos, compara√ß√µes

#### **Flag Carry (C)**
- Ativada em overflow/underflow
- Uso: Aritm√©tica de precis√£o estendida

#### **Flag Parity (P)**
- Ativada quando n√∫mero de bits '1' √© par
- Uso: Detec√ß√£o de erros, verifica√ß√µes

#### **Flag oVerflow (K)**
- C√≥pia do carry para jumps
- Uso: Jumps condicionais

---

### 3. Pipeline e Lat√™ncia

#### **Instru√ß√µes de 1 Ciclo**:
- NOP, RES, RESF
- LOAD registrador-registrador
- Opera√ß√µes l√≥gicas simples

#### **Instru√ß√µes de 2-3 Ciclos**:
- LOAD com valor imediato
- SUM, SUB (se com imediato)
- JUMP incondicional

#### **Instru√ß√µes de M√∫ltiplos Ciclos**:
- **MULT**: ~8 ciclos
- **DIV**: ~8 ciclos
- **MOD**: ~8 ciclos
- **LSHIFT/RSHIFT**: ~n ciclos (n = quantidade de shifts)

---

### 4. Endere√ßamento Indireto

Usando o registrador MA (Memory Address):

```assembly
# Carregar valor de posi√ß√£o vari√°vel da mem√≥ria

LOAD r1, 50;     # r1 = 50
LOAD ma, r1;     # MA = 50
LOAD r2, [ma];   # r2 = memory[50]
```

---

### 5. Subrotinas (Simula√ß√£o)

O processador n√£o tem CALL/RET nativos, mas pode-se simular:

```assembly
# Simular chamada de subrotina

LOAD r4, -retorno;  # Salva endere√ßo de retorno
JUMP -subrotina;

-retorno;
# C√≥digo continua aqui...

-subrotina;
# C√≥digo da subrotina
LOAD ma, r4;
JUMP [ma];          # Retorna
```

---

## üìà Desempenho e Otimiza√ß√µes

### Otimiza√ß√µes Poss√≠veis

#### **1. Uso Eficiente de Registradores**
- Manter valores frequentes em registradores matem√°ticos (x, y, z, w)
- Usar registradores de mem√≥ria (r1-r4) para armazenamento tempor√°rio

#### **2. Minimizar Acessos √† Mem√≥ria**
- LOAD imediato √© mais lento que opera√ß√£o entre registradores
- Reutilizar valores j√° carregados

#### **3. Evitar Opera√ß√µes Caras**
- Preferir LSHIFT/RSHIFT a MULT/DIV quando poss√≠vel
- Usar ADD repetido ao inv√©s de MULT para multiplicar por constantes pequenas

#### **4. Desenrolar Loops (Loop Unrolling)**
```assembly
# Ao inv√©s de:
-loop;
SUM x, y;
SUB z, 1;
JUMP -loop, n;

# Fazer:
SUM x, y;
SUM x, y;
SUM x, y;
SUM x, y;
```

---

## üêõ Debugging e Testes

### Sinais de Debug

A unidade de controle exp√µe:
- `debug_pc`: Valor atual do Program Counter
- `debug_state`: Estado atual da m√°quina de estados

**Estados**:
- 000: FETCH
- 001: DECODE
- 010: GET_VALUE1
- 011: GET_VALUE2
- 100: EXECUTE
- 101: WRITE_BACK
- 111: HALT

### Testbenches Dispon√≠veis

1. **testbench_ULA.vhd**: Testa todas opera√ß√µes da ULA
2. **testbench_SUM.vhd**: Testa somador
3. **testbench_SUB.vhd**: Testa subtrator
4. **testbench_MULT.vhd**: Testa multiplicador
5. **testbench_DIV_MOD.vhd**: Testa divisor/m√≥dulo
6. **testbench_BW.vhd**: Testa opera√ß√µes bit-wise
7. **testbench_S.vhd**: Testa shifts
8. **testbench_REG.vhd**: Testa banco de registradores
9. **testbench_comp.vhd**: Testa comparador

---

## üìö Refer√™ncias e Recursos

### Arquivos Principais do Projeto

```
Processador/
‚îú‚îÄ‚îÄ Entitys/
‚îÇ   ‚îú‚îÄ‚îÄ C_UNIT.vhd          # Unidade de Controle
‚îÇ   ‚îú‚îÄ‚îÄ ULA.vhd             # ULA completa
‚îÇ   ‚îú‚îÄ‚îÄ archive.vhd         # Mem√≥ria ROM
‚îÇ   ‚îú‚îÄ‚îÄ pack_register.vhd   # Banco de registradores
‚îÇ   ‚îú‚îÄ‚îÄ sum.vhd             # Somador
‚îÇ   ‚îú‚îÄ‚îÄ sub.vhd             # Subtrator
‚îÇ   ‚îú‚îÄ‚îÄ mult.vhd            # Multiplicador
‚îÇ   ‚îú‚îÄ‚îÄ DIV_MOD.vhd         # Divisor/M√≥dulo
‚îÇ   ‚îú‚îÄ‚îÄ bit_wise.vhd        # Opera√ß√µes l√≥gicas
‚îÇ   ‚îú‚îÄ‚îÄ l_shift.vhd         # Shift esquerda
‚îÇ   ‚îú‚îÄ‚îÄ r_shift.vhd         # Shift direita
‚îÇ   ‚îú‚îÄ‚îÄ comp.vhd            # Comparador
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Testbench's/
‚îÇ   ‚îú‚îÄ‚îÄ packages.vhd        # Pacotes auxiliares
‚îÇ   ‚îú‚îÄ‚îÄ testebench_ULA.vhd
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Compiler/
‚îÇ   ‚îú‚îÄ‚îÄ compiler.cpp        # Compilador
‚îÇ   ‚îî‚îÄ‚îÄ teste2.gbf          # Exemplo de c√≥digo
‚îî‚îÄ‚îÄ DOCUMENTACAO.md         # Este documento
```

### Extens√µes Futuras

1. **Interrupts**: Sistema de interrup√ß√µes
2. **Stack**: Pilha para subrotinas
3. **RAM**: Mem√≥ria de escrita
4. **I/O**: Portas de entrada/sa√≠da
5. **DMA**: Acesso direto √† mem√≥ria
6. **Cache**: Cache de instru√ß√µes
7. **Pipeline**: Pipeline de execu√ß√£o
8. **Floating Point**: Aritm√©tica de ponto flutuante

---

## üéâ Conclus√£o

Este processador de 8 bits √© um sistema completo e funcional que demonstra os conceitos fundamentais de arquitetura de computadores:

‚úÖ **Ciclo de Busca-Decodifica√ß√£o-Execu√ß√£o**
‚úÖ **Unidade L√≥gica Aritm√©tica com 12 opera√ß√µes**
‚úÖ **Sistema de registradores organizado**
‚úÖ **Conjunto de instru√ß√µes rico e extens√≠vel**
‚úÖ **Suporte a saltos condicionais e incondicionais**
‚úÖ **Flags de status para controle de fluxo**
‚úÖ **Opera√ß√µes aritm√©ticas, l√≥gicas e de deslocamento**
‚úÖ **Compilador assembly funcional**

O processador √© capaz de executar programas complexos incluindo loops, condicionais, opera√ß√µes aritm√©ticas avan√ßadas e manipula√ß√£o de bits, fornecendo uma base s√≥lida para entender como processadores reais funcionam internamente.

---

## üìû Informa√ß√µes Adicionais

**Vers√£o**: 1.0
**Data**: Outubro 2025
**Linguagem**: VHDL (IEEE 1076-2008)
**Simulador Recomendado**: ModelSim, GHDL, ou Vivado

---

*Documenta√ß√£o gerada para apresenta√ß√£o acad√™mica do projeto de processador de 8 bits.*
