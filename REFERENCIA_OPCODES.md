# Refer√™ncia R√°pida de Opcodes - Processador 8-bit

## Formato de Instru√ß√µes

Cada instru√ß√£o tem 1 a 3 bytes:
- **Byte 1:** Opcode (define opera√ß√£o e registradores)
- **Byte 2:** Valor imediato 1 (opcional)
- **Byte 3:** Valor imediato 2 (opcional)

---

## Conven√ß√µes de Nomenclatura

### Registradores de Mem√≥ria (r1-r4):
- `r1` = mem_regs[0]
- `r2` = mem_regs[1]
- `r3` = mem_regs[2]
- `r4` = mem_regs[3]

### Registradores Matem√°ticos (x,y,z,w):
- `x` = math_regs[0]
- `y` = math_regs[1]
- `z` = math_regs[2]
- `w` = math_regs[3]

---

## Instru√ß√µes de Transfer√™ncia de Dados

### LOAD mem_reg ‚Üê valor imediato (0x3X)
**Formato:** `0x3[dest][dest]` `[valor]`  
**Exemplo:** `0x30 0x05` = LOAD r1, 5

| Opcode | Instru√ß√£o | Descri√ß√£o |
|--------|-----------|-----------|
| 0x30   | LOAD r1, V | r1 = pr√≥ximo byte |
| 0x35   | LOAD r2, V | r2 = pr√≥ximo byte |
| 0x3A   | LOAD r3, V | r3 = pr√≥ximo byte |
| 0x3F   | LOAD r4, V | r4 = pr√≥ximo byte |

### LOAD math_reg ‚Üê mem_reg (0x1X)
**Formato:** `0x1[dest][src]`  
**Exemplo:** `0x10` = LOAD x, r1

| Opcode | Instru√ß√£o | Descri√ß√£o |
|--------|-----------|-----------|
| 0x10   | LOAD x, r1 | x = r1 |
| 0x14   | LOAD x, r2 | x = r2 |
| 0x15   | LOAD y, r2 | y = r2 |
| 0x18   | LOAD x, r3 | x = r3 |
| 0x1C   | LOAD x, r4 | x = r4 |

### LOAD mem_reg ‚Üê math_reg (0x2X)
**Formato:** `0x2[src][dest]`  
**Exemplo:** `0x20` = LOAD r1, x

| Opcode | Instru√ß√£o | Descri√ß√£o |
|--------|-----------|-----------|
| 0x20   | LOAD r1, x | r1 = x |
| 0x25   | LOAD r2, y | r2 = y |
| 0x2A   | LOAD r3, z | r3 = z |
| 0x2F   | LOAD r4, w | r4 = w |

### LOAD mem_reg ‚Üê mem_reg (0x3X)
**Formato:** `0x3[dest][src]` (quando dest ‚â† src)  
**Exemplo:** `0x36` = LOAD r2, r1

| Opcode | Instru√ß√£o | Descri√ß√£o |
|--------|-----------|-----------|
| 0x31   | LOAD r1, r1 | r1 = r1 (autocopia) |
| 0x36   | LOAD r2, r1 | r2 = r1 |
| 0x34   | LOAD r1, r2 | r1 = r2 |

---

## Opera√ß√µes Aritm√©ticas

### SOMA (0x6X)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x61   | SUM x, y  | x = x + y | 1 |
| 0x64   | SUM x, z  | x = x + z | 1 |
| 0x65   | SUM y, z  | y = y + z | 1 |
| 0x6D   | SUM x, V  | x = x + pr√≥ximo byte | 2 |
| 0x6E   | SUM V1, V2| x = V1 + V2 | 3 |

**Exemplo 3 bytes:**
```
0x6E 0x0A 0x14  = SUM 10, 20  ‚Üí x = 30
```

### SUBTRA√á√ÉO (0xBX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0xB5   | SUB y, x  | y = y - x | 1 |
| 0xB9   | SUB z, x  | z = z - x | 1 |
| 0xBD   | SUB x, V  | x = x - pr√≥ximo byte | 2 |
| 0xBE   | SUB V1, V2| x = V1 - V2 | 3 |

**Exemplo:**
```
0xBD 0x0F  = SUB x, 15  ‚Üí x = x - 15
```

### MULTIPLICA√á√ÉO (0x7X)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x74   | MULT x, y | x = x * y | 1 |
| 0x78   | MULT x, z | x = x * z | 1 |
| 0x7D   | MULT x, V | x = x * pr√≥ximo byte | 2 |
| 0x7E   | MULT V1, V2| x = V1 * V2 | 3 |

**Exemplo:**
```
0x7D 0x06  = MULT x, 6  ‚Üí x = x * 6
```

### DIVIS√ÉO (0xCX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0xCC   | DIV x, y  | x = x / y | 1 |
| 0xCD   | DIV x, V  | x = x / pr√≥ximo byte | 2 |

### M√ìDULO (0xDX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0xDC   | MOD x, y  | x = x % y | 1 |
| 0xDD   | MOD x, V  | x = x % pr√≥ximo byte | 2 |

---

## Opera√ß√µes L√≥gicas

### AND (0x8X)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x85   | AND x, y  | x = x & y | 1 |
| 0x89   | AND x, z  | x = x & z | 1 |
| 0x8D   | AND x, V  | x = x & pr√≥ximo byte | 2 |
| 0x8E   | AND V1, V2| x = V1 & V2 | 3 |

### OR (0x9X)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x99   | OR x, y   | x = x \| y | 1 |
| 0x9D   | OR x, V   | x = x \| pr√≥ximo byte | 2 |
| 0x9E   | OR V1, V2 | x = V1 \| V2 | 3 |

### XOR (0xAX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0xA9   | XOR x, y  | x = x ^ y | 1 |
| 0xAD   | XOR x, V  | x = x ^ pr√≥ximo byte | 2 |
| 0xAE   | XOR V1, V2| x = V1 ^ V2 | 3 |

### NOT (0x8X)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x8D   | NOT x     | x = ~x    | 1 |
| 0x89   | NOT V     | x = ~pr√≥ximo byte | 2 |

---

## Opera√ß√µes de Shift

### LEFT SHIFT (0xCX, 0xDX, 0xFX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0xC0   | LSHIFT x, V | x = x << pr√≥ximo byte | 2 |
| 0xF4   | LSHIFT x, y | x = x << y | 1 |

### RIGHT SHIFT (0x5X, 0x9X, 0xAX)

| Opcode | Instru√ß√£o | Descri√ß√£o | Bytes |
|--------|-----------|-----------|-------|
| 0x50   | RSHIFT wx, V | wx = wx >> pr√≥ximo byte | 2 |
| 0x94   | RSHIFT x, y  | x = x >> y | 1 |

---

## Instru√ß√µes de Controle

### NOP (0x00)
**Opcode:** `0x00`  
**Descri√ß√£o:** Nenhuma opera√ß√£o (halt quando PC > tamanho do programa)

### RES (0x01)
**Opcode:** `0x01`  
**Descri√ß√£o:** Reset dos registradores (atrav√©s do sinal global reset)

### RESF (0x02)
**Opcode:** `0x02`  
**Descri√ß√£o:** Reset das flags (Z, N, C, P, K = 0)

### JUMP (0x5X)
**Formato:** `0x5[cond]` `[endere√ßo]` `[flags]` (opcional)  
**Exemplo:** `0x54 0x10` = JUMP 16 (incondicional)

---

## Formato de Opcode (Estrutura de Bits)

```
Bit:  7  6  5  4  3  2  1  0
      [  Tipo  ][Dest/Op][Src]

Tipo (bits 7-4): Define a categoria da opera√ß√£o
Dest (bits 3-2): Registrador destino (0=x/r1, 1=y/r2, 2=z/r3, 3=w/r4)
Src  (bits 1-0): Registrador fonte ou modo
```

---

## Exemplos de Programas

### Exemplo 1: Calcular (5 + 3) * 2
```assembly
0x30 0x05    ; LOAD r1, 5
0x35 0x03    ; LOAD r2, 3
0x10         ; LOAD x, r1      (x=5)
0x15         ; LOAD y, r2      (y=3)
0x61         ; SUM x, y        (x=8)
0x7D 0x02    ; MULT x, 2       (x=16)
```

### Exemplo 2: Opera√ß√£o L√≥gica (15 AND 51)
```assembly
0x30 0x0F    ; LOAD r1, 15
0x35 0x33    ; LOAD r2, 51
0x10         ; LOAD x, r1
0x15         ; LOAD y, r2
0x85         ; AND x, y        (x=3)
```

### Exemplo 3: Divis√£o e M√≥dulo
```assembly
0x30 0x0A    ; LOAD r1, 10
0x35 0x03    ; LOAD r2, 3
0x10         ; LOAD x, r1      (x=10)
0x15         ; LOAD y, r2      (y=3)
0xCC         ; DIV x, y        (x=3)
0x10         ; LOAD x, r1      (x=10 novamente)
0xDC         ; MOD x, y        (x=1)
```

---

## Flags de Estado

Ap√≥s opera√ß√µes, flags s√£o atualizadas:

| Flag | Bit | Descri√ß√£o |
|------|-----|-----------|
| Z    | 0   | Zero: resultado = 0 |
| N    | 1   | Negative: bit 7 = 1 |
| C    | 2   | Carry: overflow da opera√ß√£o |
| P    | 3   | Parity: n√∫mero par de bits 1 |
| K    | 7   | Overflow da ULA |

---

## Notas Importantes

1. **Todas as opera√ß√µes matem√°ticas/l√≥gicas escrevem em math_regs (x,y,z,w)**
2. **Valores imediatos podem ter 1 ou 2 bytes extras**
3. **PC incrementa automaticamente ap√≥s ler cada byte**
4. **HALT ocorre quando PC > tamanho do programa em um NOP**
5. **Componentes s√≠ncronos precisam de 1 ciclo para atualizar**

---

## Quick Reference Card

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  LOAD: 0x3X (imm), 0x1X (m‚Üím), 0x2X (m‚Üír)
‚îÇ  SUM:  0x6X                           ‚îÇ
‚îÇ  SUB:  0xBX                           ‚îÇ
‚îÇ  MULT: 0x7X                           ‚îÇ
‚îÇ  DIV:  0xCX                           ‚îÇ
‚îÇ  MOD:  0xDX                           ‚îÇ
‚îÇ  AND:  0x8X                           ‚îÇ
‚îÇ  OR:   0x9X                           ‚îÇ
‚îÇ  XOR:  0xAX                           ‚îÇ
‚îÇ  NOT:  0x8D                           ‚îÇ
‚îÇ  NOP:  0x00                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üéØ **Pronto para programar!**
