# Corre√ß√µes de Bugs Adicionais - Testes 11 e 12

## üêõ Bug 1: SUB com Valor Imediato (Teste 11)

### Problema
```
Instru√ß√£o: 0xBD 0x0F  (SUB x, 15)
Esperado: x = 50 - 15 = 35
Log: ULA: A=147 B=0 OP=1  ‚Üê B deveria ser 15!
```

### Causa
Caso misto n√£o tratado:
- `needs_value1='0'` (A vem de registrador)
- `needs_value2='1'` (B vem de imediato)

### Solu√ß√£o
Adicionado no EXECUTE:
```vhdl
elsif needs_value1 = '0' and needs_value2 = '1' then
    ULA_A <= math_read_data_a;  -- Registrador
    ULA_B <= operand2;          -- Imediato
```

---

## üêõ Bug 2: C√≥pia entre Memory Registers (Teste 12)

### Problema
```
Instru√ß√£o: 0x31 (LOAD r1, r2)
Vai direto para FETCH sem copiar!
```

### Causa
Lendo `mem_read_data_a` imediatamente ap√≥s configurar `mem_read_addr_a` (timing bug).

### Solu√ß√£o
**DECODE:** Vai para EXECUTE em vez de FETCH  
**EXECUTE:** L√™ `mem_read_data_a` ap√≥s 1 ciclo

---

## ‚ö†Ô∏è Limita√ß√£o Descoberta

**N√£o √© poss√≠vel fazer LOAD r1, r1** com este encoding!

Quando bits 1-0 = bits 3-2 em 0x3X, o processador assume **valor imediato**.

Exemplo:
- 0x30 = LOAD r1, [pr√≥ximo byte] (imediato)
- 0x35 = LOAD r2, [pr√≥ximo byte] (imediato)

**Autocopia n√£o √© suportada** pelo encoding atual. Design est√° correto.

---

## ‚úÖ Status

Bugs corrigidos! Teste 11 e 12 devem funcionar agora.
