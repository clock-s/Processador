# Programa de Teste Completo do Processador

Este documento descreve o programa de teste implementado em `archive_eda.vhd` para validar todas as funcionalidades do processador 8-bit.

## Estrutura dos Testes

O programa cont√©m 12 testes diferentes cobrindo todas as opera√ß√µes principais da ULA e transfer√™ncias de dados.

---

## Teste 1: Opera√ß√£o B√°sica de SOMA
**Endere√ßos:** 0-6  
**Objetivo:** Validar LOAD de valores imediatos, transfer√™ncia entre registradores e opera√ß√£o SUM

```assembly
LOAD r1, 5      ; r1 = 5
LOAD r2, 3      ; r2 = 3
LOAD x, r1      ; x = 5
LOAD y, r2      ; y = 3
SUM x, y        ; x = 5 + 3 = 8
```

**Resultado Esperado:** `x = 8`

---

## Teste 2: Opera√ß√£o de SUBTRA√á√ÉO
**Endere√ßos:** 7-10  
**Objetivo:** Validar opera√ß√£o SUB entre registradores

```assembly
LOAD r3, 10     ; r3 = 10
LOAD x, r3      ; x = 10
SUB y, x        ; y = 3 - 10 = -7 (249 em unsigned 8-bit)
```

**Resultado Esperado:** `y = 249` (complemento de 2 de -7)

---

## Teste 3: Opera√ß√£o de MULTIPLICA√á√ÉO
**Endere√ßos:** 11-17  
**Objetivo:** Validar opera√ß√£o MULT entre registradores

```assembly
LOAD r1, 4      ; r1 = 4
LOAD r2, 3      ; r2 = 3
LOAD x, r2      ; x = 3
LOAD y, r1      ; y = 4
MULT x, y       ; x = 3 * 4 = 12
```

**Resultado Esperado:** `x = 12`

---

## Teste 4: Opera√ß√£o L√≥gica AND
**Endere√ßos:** 18-24  
**Objetivo:** Validar opera√ß√£o AND bit-a-bit

```assembly
LOAD r1, 15     ; r1 = 15  (0b00001111)
LOAD r2, 51     ; r2 = 51  (0b00110011)
LOAD x, r1      ; x = 15
LOAD y, r2      ; y = 51
AND x, y        ; x = 15 & 51 = 3 (0b00000011)
```

**Resultado Esperado:** `x = 3`

**Explica√ß√£o:**
```
  00001111  (15)
& 00110011  (51)
----------
  00000011  (3)
```

---

## Teste 5: Opera√ß√£o L√≥gica OR
**Endere√ßos:** 25-31  
**Objetivo:** Validar opera√ß√£o OR bit-a-bit

```assembly
LOAD r1, 12     ; r1 = 12  (0b00001100)
LOAD r2, 3      ; r2 = 3   (0b00000011)
LOAD x, r1      ; x = 12
LOAD y, r2      ; y = 3
OR x, y         ; x = 12 | 3 = 15 (0b00001111)
```

**Resultado Esperado:** `x = 15`

**Explica√ß√£o:**
```
  00001100  (12)
| 00000011  (3)
----------
  00001111  (15)
```

---

## Teste 6: Opera√ß√£o L√≥gica XOR
**Endere√ßos:** 32-38  
**Objetivo:** Validar opera√ß√£o XOR bit-a-bit

```assembly
LOAD r1, 15     ; r1 = 15  (0b00001111)
LOAD r2, 10     ; r2 = 10  (0b00001010)
LOAD x, r1      ; x = 15
LOAD y, r2      ; y = 10
XOR x, y        ; x = 15 ^ 10 = 5 (0b00000101)
```

**Resultado Esperado:** `x = 5`

**Explica√ß√£o:**
```
  00001111  (15)
^ 00001010  (10)
----------
  00000101  (5)
```

---

## Teste 7: Opera√ß√£o de INVERS√ÉO (NOT)
**Endere√ßos:** 39-42  
**Objetivo:** Validar opera√ß√£o NOT (invers√£o de bits)

```assembly
LOAD r1, 170    ; r1 = 170 (0xAA = 0b10101010)
LOAD x, r1      ; x = 170
NOT x           ; x = ~170 = 85 (0x55 = 0b01010101)
```

**Resultado Esperado:** `x = 85`

**Explica√ß√£o:**
```
Original: 10101010  (170)
NOT:      01010101  (85)
```

---

## Teste 8: Transfer√™ncia Mem√≥ria ‚Üê Matem√°tica
**Endere√ßos:** 43-46  
**Objetivo:** Validar c√≥pia de registrador matem√°tico para registrador de mem√≥ria (0x2X)

```assembly
LOAD r1, 99     ; r1 = 99
LOAD x, r1      ; x = 99
LOAD r1, x      ; r1 = x = 99 (copia x de volta para r1)
```

**Resultado Esperado:** `r1 = 99`, `x = 99`

---

## Teste 9: SOMA com Valores Imediatos
**Endere√ßos:** 47-49  
**Objetivo:** Validar SUM com dois valores imediatos (0x6E)

```assembly
SUM V1, V2      ; x = 10 + 20 = 30
  .byte 10      ; V1 = 10
  .byte 20      ; V2 = 20
```

**Resultado Esperado:** `x = 30`

---

## Teste 10: MULTIPLICA√á√ÉO com Valor Imediato
**Endere√ßos:** 50-54  
**Objetivo:** Validar MULT com registrador e valor imediato (0x7D)

```assembly
LOAD r1, 5      ; r1 = 5
LOAD x, r1      ; x = 5
MULT x, V       ; x = 5 * 6 = 30
  .byte 6       ; V = 6
```

**Resultado Esperado:** `x = 30`

---

## Teste 11: SUBTRA√á√ÉO com Valor Imediato
**Endere√ßos:** 55-59  
**Objetivo:** Validar SUB com registrador e valor imediato (0xBD)

```assembly
LOAD r3, 50     ; r3 = 50
LOAD x, r3      ; x = 50
SUB x, V        ; x = 50 - 15 = 35
  .byte 15      ; V = 15
```

**Resultado Esperado:** `x = 35`

---

## Teste 12: C√≥pia Entre Registradores de Mem√≥ria
**Endere√ßos:** 60-63  
**Objetivo:** Validar c√≥pia entre registradores de mem√≥ria (0x3X com src‚â†dest)

```assembly
LOAD r1, 77     ; r1 = 77
LOAD r1, r1     ; r1 = r1 (autocopia, mant√©m 77)
LOAD r2, r1     ; r2 = r1 = 77 (copia r1 para r2)
```

**Resultado Esperado:** `r1 = 77`, `r2 = 77`

---

## Resumo de Resultados Esperados

| Teste | Opera√ß√£o | Resultado Final |
|-------|----------|----------------|
| 1  | SUM      | x = 8          |
| 2  | SUB      | y = 249 (-7)   |
| 3  | MULT     | x = 12         |
| 4  | AND      | x = 3          |
| 5  | OR       | x = 15         |
| 6  | XOR      | x = 5          |
| 7  | NOT      | x = 85         |
| 8  | LOAD     | r1 = 99, x = 99|
| 9  | SUM imm  | x = 30         |
| 10 | MULT imm | x = 30         |
| 11 | SUB imm  | x = 35         |
| 12 | C√≥pia    | r1 = 77, r2 = 77|

---

## Cobertura de Instru√ß√µes

Este programa testa:

### Opera√ß√µes Aritm√©ticas:
- ‚úÖ SUM (registrador-registrador e imediato-imediato)
- ‚úÖ SUB (registrador-registrador e registrador-imediato)
- ‚úÖ MULT (registrador-registrador e registrador-imediato)

### Opera√ß√µes L√≥gicas:
- ‚úÖ AND (registrador-registrador)
- ‚úÖ OR (registrador-registrador)
- ‚úÖ XOR (registrador-registrador)
- ‚úÖ NOT (registrador √∫nico)

### Transfer√™ncias de Dados:
- ‚úÖ LOAD mem_reg ‚Üê valor imediato (0x3X)
- ‚úÖ LOAD math_reg ‚Üê mem_reg (0x1X)
- ‚úÖ LOAD mem_reg ‚Üê math_reg (0x2X)
- ‚úÖ LOAD mem_reg ‚Üê mem_reg (0x3X com src‚â†dest)

### Instru√ß√µes de Controle:
- ‚úÖ NOP com halt autom√°tico

---

## Como Executar no EDA Playground

1. Compile todos os arquivos na ordem:
   - `archive_eda.vhd`
   - `pack_register_mem.vhd`
   - `pack_register_math.vhd`
   - `ULA.vhd` (e todas suas depend√™ncias)
   - `C_UNIT.vhd`
   - `testbench_C_UNIT_standalone.vhd`

2. Execute a simula√ß√£o por pelo menos **2000 ns** para permitir que todos os testes executem

3. Observe os reports no console para validar cada opera√ß√£o

4. Verifique os valores finais dos registradores:
   - `mem_regs[0]` (r1) = 77
   - `mem_regs[1]` (r2) = 77
   - `mem_regs[2]` (r3) = 50
   - `math_regs[0]` (x) = 35
   - `math_regs[1]` (y) = 249

---

## Debug e Valida√ß√£o

Para cada teste, o processador emite reports detalhados:
- `FETCH: PC=X` - Mostra o contador de programa
- `DECODE: inst=Y` - Mostra a instru√ß√£o sendo decodificada
- `GET_VALUE1/2: Lendo valor imediato Z` - Mostra valores lidos da ROM
- `EXECUTE: opcode=W` - Confirma execu√ß√£o
- `ULA: A=X B=Y OP=Z` - Mostra operandos e opera√ß√£o da ULA
- `WRITE_BACK: resultado=R escrito em math_regs[N]` - Mostra resultado final

Compare os valores reportados com os esperados neste documento! üéØ
