# Corre√ß√£o: Incremento de PC ap√≥s Leitura de Imediatos

## Problema Identificado

Ap√≥s corrigir os bugs de timing, apareceu outro problema: **PC n√£o estava sendo incrementado** ap√≥s ler valores imediatos!

### Execu√ß√£o com Bug:
```
PC=0: FETCH ‚Üí DECODE: inst=48 (0x30 = LOAD r1,)
      DECODE incrementa PC para 1
      
PC=1: GET_VALUE1 l√™ valor 2 (0x02)
      GET_VALUE1 N√ÉO incrementa PC!  ‚ùå
      
PC=1: FETCH l√™ endere√ßo 1 novamente!
      DECODE: inst=3 (0x02 em decimal)  ‚ùå ERRADO!
      
Deveria ter lido endere√ßo 2 (0x35 = LOAD r2,)
```

### Consequ√™ncia:
O processador pulava instru√ß√µes ou relia valores imediatos como opcodes!

## Causa Raiz

No estado GET_VALUE1, ap√≥s ler um valor imediato da ROM, o c√≥digo s√≥ incrementava PC quando `needs_value2='1'` (caso de duas imediatas consecutivas).

Quando havia apenas **um** valor imediato (`needs_value2='0'`), o PC **n√£o era incrementado**, fazendo o pr√≥ximo FETCH reler o mesmo byte!

### Fluxo com Bug:
```
DECODE (0x30 = LOAD r1, imm):
  - PC = 0
  - PC <= PC + 1  (PC = 1, aponta para valor imediato)
  - Vai para GET_VALUE1

GET_VALUE1 (fase 1):
  - rom_addr <= PC (1)
  - waiting_rom <= '1'

GET_VALUE1 (fase 2):
  - operand1 <= instruction (0x02)
  - needs_value2 = '0'
  - PC N√ÉO √â INCREMENTADO!  ‚ùå
  - Vai para EXECUTE

FETCH:
  - rom_addr <= PC (ainda 1!)  ‚ùå
  - L√™ 0x02 novamente
```

## Solu√ß√£o Implementada

**Sempre incrementar PC** ap√≥s ler um valor imediato em GET_VALUE1, independente de needs_value2!

### C√≥digo Corrigido:
```vhdl
-- ROM updated, now read the value
operand1 <= instruction;
needs_value1 <= '0';
waiting_rom <= '0';
report "GET_VALUE1: Lendo valor imediato " & integer'image(...);

-- ‚úÖ SEMPRE incrementa PC ap√≥s ler imediato
if PC < 255 then
    PC <= PC + 1;  -- Move past the immediate value we just read
end if;

if needs_value2 = '1' then
    -- Precisa ler outro imediato
    if PC < 254 then
        rom_addr <= PC + 1;  -- Aponta para pr√≥ximo imediato
        current_state <= GET_VALUE2;
    else
        current_state <= HALT;
    end if;
else
    -- N√£o precisa de value2
    current_state <= EXECUTE;
end if;
```

### Novo Fluxo (Correto):
```
DECODE (0x30 = LOAD r1, imm):
  - PC = 0
  - PC <= 1  (aponta para valor imediato)
  - Vai para GET_VALUE1

GET_VALUE1 (fase 1):
  - rom_addr <= 1
  - waiting_rom <= '1'

GET_VALUE1 (fase 2):
  - operand1 <= 0x02
  - PC <= 2  ‚úÖ INCREMENTADO!
  - Vai para EXECUTE

EXECUTE:
  - Executa LOAD r1, 2

FETCH:
  - rom_addr <= PC (2)  ‚úÖ CORRETO!
  - L√™ 0x35 (LOAD r2,)  ‚úÖ
```

## Resultado Esperado

Agora a sequ√™ncia de PCs deve ser:
```
PC=0: LOAD r1, 2   (0x30 0x02)  ‚Üí PC incrementa para 2
PC=2: LOAD r2, 3   (0x35 0x03)  ‚Üí PC incrementa para 4
PC=4: LOAD x, r1   (0x10)       ‚Üí PC incrementa para 5
PC=5: LOAD y, r2   (0x15)       ‚Üí PC incrementa para 6
PC=6: SUM x, y     (0x61)       ‚Üí PC incrementa para 7
PC=7: NOP          (0x00)       ‚Üí HALT
```

## Li√ß√£o Aprendida

Em processadores com instru√ß√µes de **tamanho vari√°vel**, √© **cr√≠tico** incrementar PC corretamente ap√≥s ler cada byte:

1. **DECODE**: Incrementa PC para apontar para primeiro byte extra (se houver)
2. **GET_VALUE1**: Incrementa PC para apontar para segundo byte extra (se houver) ou pr√≥xima instru√ß√£o
3. **GET_VALUE2**: Incrementa PC para pr√≥xima instru√ß√£o (se houver terceiro byte)

**Nunca esquecer** de incrementar PC ap√≥s consumir um byte, mesmo que n√£o precise de mais bytes! üéØ
